{"pageProps":{"mdFile":"# JDBC\r\n\r\n## JDBC (Java DataBase Connectivity) 란?\r\n\r\n[JDBC](https://opentutorials.org/module/3569/21222)\r\n\r\n**Java**언어로 **RDB**에 접속하고 SQL 문을 수행하고 처리하기 위해 사용 되는 **표준 SQL Interface API**입니다.\r\n\r\n## JDBC 드라이버\r\n\r\nMySQL, Oracle, MariaDB 등등 **RDBMS**의 종류는 다양합니다. 문제는 **DBMS**마다 사용하는 문법이 조금씩 다르다는 것입니다.\r\n\r\n**JDBC 드라이버**는 각 **DBMS**마다 **JDBC Interface**를 상속받아 구현한 클래스들 입니다. 그래서 우리는 **JDBC**에 **JDBC 드라이버**를 넣어 원하는 **DBMS**를 문법\r\n신경 쓰지 않고, 사용할 수 있게 됩니다.\r\n\r\n이런 **JDBC 드라이버**는 각 **DBMS**마다 라이브러리를 만들어 놓았으므로 우리는 라이브러리를 추가하여 사용하면 됩니다.\r\n\r\n즉, **DBMS** 마다 각각 다른 문법에 대해 신경쓰지 않고, **JDBC**의 규칙에 맞게 작성하면, 주입된 **JDBC 드라이버**에 따라 자동으로 변환됩니다. 이것의 장점은 **MySQL**을 쓰다가\r\n**Oracle**로 변경하고자 할 때, **JDBC 드라이버**만 바꿔주면 된다는 것 입니다.\r\n\r\n> **JDBC**는 **Interface**이므로, 직접 인스턴스를 생성하여 사용 할 수 없습니다. 따라서, **JDBC 드라이버**가 필수입니다.\r\n\r\n## JDBC 사용 방법\r\n\r\n- **MySQL**을 기준으로 작성했습니다.\r\n\r\n### 드라이버 로드\r\n\r\n```java\r\npublic class Foo {\r\n\r\n  public static void main(String[] args) {\r\n    Class.forName(\"com.mysql.jdbc.Driver\");\r\n  }\r\n}\r\n```\r\n\r\n#### 드라이버 로드 시 일어나는 과정\r\n\r\n*com.mysql.jdbc.Driver*\r\n\r\n```java\r\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\r\n  public Driver() throws SQLException {\r\n  }\r\n\r\n  static {\r\n    try {\r\n      DriverManager.registerDriver(new Driver());\r\n    } catch (SQLException var1) {\r\n      throw new RuntimeException(\"Can't register driver!\");\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**JDBC 드라이버**를 동적으로 로딩하게 되면, 이 시점에 클래스 로더가 해당 클래스의 정보를 **Method Area**에 올리게 됩니다. 이 때, `static` 정보도 올라가게 되는데,\r\n`static`을 보면 `Driver`의 인스턴스를 생성해 `DriverManager.registerDriver`의 **Parameter**로 넘겨 줍니다.\r\n\r\n그래서 `DriverManager`는 **DI(의존성 주입)** 된 드라이버를 사용할 수 있게 되는 것 입니다.\r\n\r\n### DBMS 접속\r\n\r\n```java\r\npublic class Foo {\r\n\r\n  public static void main(String[] args) {\r\n    String url = \"jdbc:mysql://localhost:3306/java\";\r\n    String user = \"root\";\r\n    String password = \"root\";\r\n\r\n    Connection connection = DriverManager.getConnection(url, user, password);\r\n  }\r\n}\r\n```\r\n\r\n- url: jdbc:DBMS명://주소:DBMS포트/DB명\r\n- user: 접속 계정\r\n- password: 접속 계정 비밀번호\r\n\r\n**DBMS** 접속에 성공하면 `Connection` 객체를 반환합니다.\r\n\r\n> 드라이버가 달라지면, **드라이버 로드**와, **DBMS 접속** 코드만 달라지고 아래 코드는 동일하게 사용 가능합니다.\r\n\r\n### PreparedStatement\r\n\r\n```java\r\npublic class Foo {\r\n\r\n  public static void main(String[] args) {\r\n    PreparedStatement preparedStatement = connection.prepareStatement(\"SQL 문 작성\");\r\n  }\r\n}\r\n```\r\n\r\n`Connection` 객체까지 무사히 리턴 받았다면, 이제 **SQL 문**을 작성하여 보내고, 처리된 결과를 받아 와야 합니다.\r\n\r\n`PreparedStatement` 객체가 그 역할을 합니다.\r\n\r\n### SQL 문 작성 및 실행\r\n\r\n#### INSERT, UPDATE, DELETE\r\n\r\n```java\r\npublic class Foo {\r\n\r\n  public static void main(String[] args) {\r\n    String sql = \"INSERT INTO member VALUES(?, ?)\";\r\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\r\n\r\n    preparedStatement.setInt(1, 1);\r\n    preparedStatement.setString(2, \"Foo\");\r\n\r\n    preparedStatement.executeUpdate();\r\n  }\r\n}\r\n```\r\n\r\n#### SELECT\r\n\r\n```java\r\npublic class Foo {\r\n\r\n  public static void main(String[] args) {\r\n\r\n    String sql = \"SELECT * FROM member\";\r\n    preparedStatement = connection.prepareStatement(sql);\r\n    ResultSet resultSet = preparedStatement.executeQuery();\r\n\r\n    while (resultSet.next()) {\r\n      //      int idx = resultSet.getInt(1); // column index\r\n      int idx = resultSet.getInt(\"idx\"); // column name\r\n      System.out.println(idx);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n- preparedStatement.setXXX: 첫 번째 인자는 `?`의 인덱스가 들어가고, 두 번째 인자는 실제 값이 들어갑니다.\r\n- preparedStatement.executeXXX(): **SQL 문**을 작성하고 엔터를 친것과 같습니다.\r\n    - executeUpdate(): `INSERT`, `UPDATE`, `DELETE`\r\n    - executeQuery(): `SELECT`\r\n\r\n### close\r\n\r\n```java\r\npublic class Foo {\r\n\r\n  public static void main(String[] args) {\r\n    try {\r\n      preparedStatement.close();\r\n      connection.close();\r\n    } catch (SQLException e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n항상 작업이 끝나면 연결을 `close()` 메소드를 호출해 끊어줘야하며, `close()` 메소드 호출은 열었던 반대 순으로 호출 해야 합니다.\r\n\r\n### 전체 다 합치기\r\n\r\n```java\r\npublic class Foo {\r\n\r\n  public static void main(String[] args) {\r\n    Connection connection = null;\r\n    PreparedStatement preparedStatement = null;\r\n    ResultSet resultSet = null;\r\n\r\n    String url = \"jdbc:mysql://localhost:3306/java\";\r\n    String user = \"root\";\r\n    String password = \"root!\";\r\n    try {\r\n      Class.forName(\"com.mysql.jdbc.Driver\");\r\n      connection = DriverManager.getConnection(url, user, password);\r\n\r\n      String sql = \"SELECT * FROM member\";\r\n      preparedStatement = connection.prepareStatement(sql);\r\n      resultSet = preparedStatement.executeQuery();\r\n\r\n      while (resultSet.next()) {\r\n        int idx = resultSet.getInt(\"idx\");\r\n        System.out.println(idx);\r\n      }\r\n    } catch (ClassNotFoundException | SQLException e) {\r\n      e.printStackTrace();\r\n    } finally {\r\n      if (resultSet != null) try {\r\n        resultSet.close();\r\n      } catch (Exception throwables) {\r\n        throwables.printStackTrace();\r\n      }\r\n      if (preparedStatement != null) try {\r\n        preparedStatement.close();\r\n      } catch (Exception throwables) {\r\n        throwables.printStackTrace();\r\n      }\r\n      if (connection != null) try {\r\n        connection.close();\r\n      } catch (Exception throwables) {\r\n        throwables.printStackTrace();\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n예외가 발생하기 때문에 `try ~ catch`로 감싸줘야 하며, 예외 상관없이 `close()`를 해줘야하기 때문에 `finally`로 해당 작업을 뺐습니다.\r\n`finally`로 해당 작업을 빼면 `try ~ catch` 내에서 생성된 객체는 공유되지 않으므로, `try ~ catch` 밖에 선언해 두었습니다.","headTitle":"JDBC","fileList":[]},"__N_SSG":true}