{"pageProps":{"mdFile":"# Overriding (오버라이딩)\r\n\r\n## Overriding 이란?\r\n\r\n상속 관계에서 부모 클래스가 정의 해 놓은 메소드를 자식 클래스가 재정의 하는 것을 말합니다.\r\n\r\n> Overriding이 있기에 클래스 다형성이 가능합니다.\r\n\r\n## Overriding 규칙\r\n\r\n- 부모클래스의 메소드와 시그니처(**리턴 타입, 메소드 명, 매개변수**)가 동일해야 합니다.\r\n- 접근 제한자는 더 좁아질 수 없습니다.\r\n- 새로운 예외를 `throws` 할 수 없습니다.\r\n\r\n## Overriding 하는 방법\r\n\r\n*Foo.java*\r\n```java\r\npublic class Foo {\r\n\r\n  public void print() {\r\n    System.out.println(\"Foo\");\r\n  }\r\n}\r\n```\r\n\r\n*Goo.java*\r\n```java\r\npublic class Goo extends Foo {\r\n\r\n  @Override\r\n  public void print() {\r\n    System.out.println(\"Goo\");\r\n  }\r\n}\r\n```\r\n\r\n- `@Override` 는 없어도 무관하지만, 만약 시그니처가 다른 메소드를 정의한다면 그건 **Overloading**이 됩니다. 실수로 그런 상황이 발생 했을 때 이상하다고 알려주는 **Annotation**이기 때문에 대도록 붙여주시는게 좋습니다.\r\n\r\n*Ex.java*\r\n```java\r\npublic class Ex {\r\n\r\n  public void main(String[] args) {\r\n    Foo foo = new Foo();\r\n    foo.print(); // Foo\r\n\r\n    Goo goo = new Goo();\r\n    goo.print(); // Goo\r\n  }\r\n}\r\n```\r\n\r\n부모 클래스로 부터 상속받은 메소드를 재정의 하면, 부모 클래스의 메소드는 **은닉** 됩니다.\r\n따라서, 해당 메소드를 사용하면 재정의 된 메소드가 실행됩니다.\r\n\r\n## 클래스의 다형성\r\n\r\n**클래스의 다형성**은 하나의 자료형에 다른 객체를 넣어 다양한 결과를 가져 오는 것을 말합니다.\r\n\r\n*Foo.java*\r\n```java\r\npublic class Foo {\r\n\r\n  public void print() {\r\n    System.out.println(\"Foo\");\r\n  }\r\n}\r\n```\r\n\r\n*Goo.java*\r\n```java\r\npublic class Goo extends Foo {\r\n\r\n  @Override\r\n  public void print() {\r\n    System.out.println(\"Goo\");\r\n  }\r\n}\r\n```\r\n\r\n*Ex.java*\r\n```java\r\npublic class Ex {\r\n\r\n  public void main(String[] args) {\r\n    Foo goo = new Goo();\r\n    goo.print(); // Goo\r\n  }\r\n}\r\n```\r\n\r\n`Goo` 클래스는 `Foo` 클래스를 상속 받았기 때문에 **UpCasting**이 가능합니다.\r\n**UpCasting**을 하면 객체의 주소는 그대로지만, `Foo` 클래스가 사용할 수 있는 범위에서만 사용이 가능합니다. (위의 경우는 **UpCasting**을 해도 동일)\r\n\r\n하지만 생성된 객체는 여전히 같으므로 `print()` 메소드를 호출하면 `Goo` 클래스에서 재정의 된 `print()` 메소드가 호출 됩니다.\r\n\r\n> 하나의 자료형에 다른 객체를 넣어 다양한 결과를 가져 오는 것. 그것이 클래스의 다형성입니다.","headTitle":"Overriding (오버라이딩)","fileList":[]},"__N_SSG":true}