{"pageProps":{"mdFile":"# Abstraction (추상화)\r\n\r\n## 추상화 란?\r\n\r\n자식 클래스에서 공통점을 추출하여 부모 클래스에 선언하는 것을 말합니다.\r\n\r\n## 추상 클래스 (Abstract Class) 란?\r\n\r\n일반 클래스에서 추상화가 추가 된 클래스 입니다.\r\n\r\n### 추상 클래스의 특징\r\n\r\n- 추상 클래스는 직접 인스턴스를 생성할 수 없습니다.\r\n- 추상 클래스에 선언된 추상 메소드는 **반드시 Overriding**해야 합니다.\r\n\r\n### 추상 클래스 사용 방법\r\n\r\n- 접근 제한자 뒤에 `abstract` 키워드를 붙여 만들 수 있습니다.\r\n\r\n*Foo.java*\r\n\r\n```java\r\npublic abstract class Foo {\r\n  public abstract void print();\r\n\r\n  public void println() {\r\n    System.out.println(\"Foo\");\r\n  }\r\n}\r\n```\r\n\r\n*Goo.java*\r\n\r\n```java\r\npublic class Goo extends Foo {\r\n  @Override\r\n  public void print() {\r\n    System.out.println(\"Goo\");\r\n  }\r\n}\r\n```\r\n\r\n*Ex.java*\r\n\r\n```java\r\npublic class Ex {\r\n  public static void main(String[] args) {\r\n    Foo foo = new Foo(); // error\r\n    Foo goo = new Goo(); // 가능\r\n\r\n    goo.print(); // Goo\r\n    goo.println(); // Foo\r\n  }\r\n}\r\n```\r\n\r\n기본적으로 일반 클래스 상속과 똑같지만, `abstract` 키워드가 들어간 메소드는 반드시 **Overriding** 해야 하며, 직접 인스턴스 생성은 불가능 하여, 자식 인스턴스를 주입 받아야 합니다. 그렇다고\r\n추상 클래스에 무조건 추상 메소드가 들어갈 필요는 없습니다.\r\n\r\n추상 메소드를 **Overriding**하기 싫다면, 해당 클래스로 추상 클래스가 되면 됩니다.\r\n\r\n> 단, 그렇다고 하더라도 `abstract` 키워드가 붙은 클래스(추상 클래스)는 인스턴스를 직접 생성할 수는 없고, 반드시 자식 클래스의 인스턴스를 주입 받아야 합니다.\r\n\r\n## 인터페이스 (Interface) 란?\r\n\r\n`class`들이 구현해야 하는 동작을 지정하는데 사용되는 자료형입니다.\r\n\r\n`interface`를 받아 **Overriding**하는 클래스를 **구현 클래스**라고 합니다\r\n\r\n> 추상 클래스가 일반 클래스 + 추상화라면, 인터페이스는 Only 추상화입니다.\r\n\r\n### 인터페이스 특징\r\n\r\n- 상수와, 추상 메소드만 가질 수 있습니다.\r\n- 상속과는 다르게 다중 구현이 가능합니다.\r\n- 인터페이스는 직접 인스턴스를 생성할 수 없습니다.\r\n- 인터페이스에 선언된 추상 메소드는 **반드시 Overriding**해야 합니다.\r\n\r\n### 인터페이스 사용 방법\r\n\r\n*Foo.interface*\r\n\r\n```java\r\npublic interface Foo {\r\n  String name = \"foo\";\r\n\r\n  void print();\r\n}\r\n```\r\n\r\n*Goo.interface*\r\n\r\n```java\r\npublic interface Goo {\r\n  int age = 24;\r\n\r\n  void print(String name);\r\n}\r\n```\r\n\r\n- `class` 대신 `interface`를 적습니다.\r\n- `interface`는 정적 상수와 추상 메소드만 가능합니다.\r\n    - 필드앞에 `public static final` 생략되어 있습니다.\r\n    - 메소드 앞에 `public abstract` 생략 되어 있습니다.\r\n\r\n*Hoo.class*\r\n\r\n```java\r\npublic class Hoo implements Foo, Goo {\r\n\r\n  @Override\r\n  public void print() {\r\n    System.out.println(\"Foo Interface\");\r\n  }\r\n\r\n  @Override\r\n  public void print(String name) {\r\n    System.out.println(\"Goo Interface\");\r\n  }\r\n}\r\n```\r\n\r\n- `implements` 키워드를 이용해서 여러 개의 `interface`를 다중 구현 할 수 있습니다.\r\n- 전부 추상 메소드이기 때문에, 전부 **Overriding** 해주어야 합니다.\r\n\r\n*Ex.java*\r\n\r\n```java\r\npublic class Ex {\r\n\r\n  public static void main(String[] args) {\r\n    Foo foo = new Hoo();\r\n    Goo goo = new Hoo();\r\n\r\n    foo.print(); // Foo Interface\r\n    goo.print(\"goo\"); // Goo interface\r\n  }\r\n}\r\n```\r\n\r\n- 두 개의 `interface`를 다중 구현 했기 때문에, 두 개의 `interface`로 모두 **UpCasting**이 가능합니다.\r\n\r\n### 인터페이스 다중 상속\r\n\r\n*Foo.interface*\r\n\r\n```java\r\npublic interface Foo {\r\n  void printFoo();\r\n}\r\n```\r\n\r\n*Goo.interface*\r\n\r\n```java\r\npublic interface Goo {\r\n  void printGoo();\r\n}\r\n```\r\n\r\n*Hoo.interface*\r\n\r\n```java\r\npublic interface Hoo extends printFoo, printGoo {\r\n  void printHoo();\r\n}\r\n```\r\n\r\n*Joo.java*\r\n\r\n```java\r\npublic class Joo implements Hoo {\r\n\r\n  @Override\r\n  public void printFoo() {\r\n    System.out.println(\"Foo\");\r\n  }\r\n\r\n  @Override\r\n  public void printGoo() {\r\n    System.out.println(\"Goo\");\r\n  }\r\n\r\n  @Override\r\n  public void printHoo() {\r\n    System.out.println(\"Hoo\");\r\n  }\r\n}\r\n```\r\n\r\n`class`에서 `interface`는 `extends`로 받을 수 없고 반드시 `implements`로 받아야 합니다. 반면, `interface`가 `interface`를 받을 땐, `extends` 키워드를\r\n사용하여 상속 받아야 합니다.\r\n\r\n> `class`가 `interface`를 받을 땐 **구현**을 해야하는 것이고, `interface`가 `interface`를 받을 땐, **확장**을 하는 개념이기 때문입니다.\r\n\r\n`class`는 `extends`는 하나만 가능하나, `implements`는 여러 개가 가능한 반면,\r\n`interface`는 `extends`는 여러 개를 받을 수 있으나, `implements`는 불가능합니다.\r\n\r\n### interface에 implements를 사용할 수 없는 이유\r\n\r\n`implements` 키워드를 사용하여 받으면, 무조건 받은 `interface`를 **Overriding**을 해야 합니다. 그런데 `interface`는 **Overriding**이 불가능 하기 때문에 사용할\r\n수 없는 것 입니다.\r\n\r\n### class는 단일 상속만 되고, interface는 다중 상속이 가능한 이유\r\n\r\n상속은 기능을 확장하는 기능입니다. 그런데, `class`는 **Overriding**하지 않으면 부모가 정의한 기능을 그대로 사용하게 됩니다. 이 때, 여러 개의 부모 클래스가 같은 이름의 메소드를 정의하였다면,\r\n자식 클래스는 어떤 메소드를 호출해야할지 모르기 때문에 다중 상속이 불가능합니다.\r\n\r\n반면, `interface`는 여러 개의 부모를 상속 받더라도, 똑같은 시그니처의 메소드가 있다면, 하나만 선언해두고, 해당 `interface`를 `implements`받은 `class`에서 해당 메소드를\r\n**Overriding**하면, 상속 받은 모든 `interface`에서 **Overriding**한 메소드를 사용하면 되기 때문에 혼란이 없습니다.\r\n\r\n> 즉, `interface`의 상속은 무조건 **Overriding**을 하기 때문에 어떤 것을 사용해야 할지 아는 반면,\r\n> `class`의 상속은 **Overriding**에 대한 강제성이 없기 때문에, 메소드 호출에 혼란이 있을 수 있어 다중 상속이 불가능합니다.\r\n","headTitle":"Abstraction (추상화)","fileList":[]},"__N_SSG":true}