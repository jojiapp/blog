{"pageProps":{"mdFile":"# Casting (형 변환)\r\n\r\n## 형 변환 이란?\r\n\r\n- 현재 타입을 다른 타입으로 변환하는 것을 형 변환이라고 합니다.\r\n\r\n> 형 변환은 OOP에서 다형성과 연관이 있습니다.\r\n\r\n## 자동 형 변환 (묵시적 형 변환)\r\n\r\n변환 될 타입이 현재 타입을 모두 담아 낼 수 있다면,\r\n즉, 더 크다면 명시적으로 타입을 지정해 주지 않아도 형 변환이 됩니다.\r\n\r\n```java\r\nint num1 = 10;\r\ndouble num2 = num1; // 10.0\r\n```\r\n\r\n- `double`형이 `int`형 보다 크기 때문에, 아무 문제 없이 됩니다.\r\n\r\n## 강제 형 변환\r\n\r\n자동 형 변환과 반대로, 변환 될 타입이 현재 타입을 모두 담아 낼 수 없다면,\r\n즉, 더 작다면 명시적으로 타입을 지정해 주어야 합니다.\r\n\r\n```java\r\ndouble num1 = 10.0;\r\nint num2 = num1; // error\r\n\r\nint num3 = (int) num1; // 10\r\n```\r\n\r\n- `double`형이 `int`형 보다 크기 때문에,\r\n`int`형으로 변환 할거다 라는 것을 명시적으로 적어줘야 합니다.\r\n\r\n## 연산 할 때 일어나는 형 변환\r\n\r\n각각 다른 타입으로 연산을 한다면 기본적으로 더 큰 타입으로 변환됩니다.\r\n\r\n```java\r\nint num1 = 10;\r\ndouble num2 = 10.0;\r\n\r\ndouble num3 = num1 + num2;\r\n```\r\n\r\n- `double`형이 `int`형 보다 더 큰 자료형 이므로 `double`형으로 자동 형 변환이 일어납니다.\r\n\r\n```java\r\nlong num1 = 10L;\r\nfloat num2 = 10.0f;\r\n\r\nfloat num3 = num1 + num2;\r\n```\r\n\r\n- bytes는 `long`타입이 더 크지만, 실수형은 기본적으로 정수형 보다 큽니다. 따라서, 위는 `float`형으로 자동 형 변환이 일어납니다.\r\n\r\n```java\r\nbyte num1 = 10;\r\nbyte num2 = 10;\r\n\r\nbyte num3 = num1 + num2; // error\r\nint num4 = num1 + num2;\r\n```\r\n\r\n- `byte` + `byte` 라서 `byte`로 나올거 같았지만, 이상하게도 되지 않습니다.\r\n- 그 이유는, `int`형 아래 타입들은 연산을 하게 되면 모두 `int`형으로 변환되기 때문입니다. (정수형의 기본 타입은 `int`)\r\n\r\n## 참조형 타입의 형 변환\r\n\r\n참조형 타입도 위와 같은 논리가 적용됩니다. 따라서, 더 많은 것을 가지고 있는 쪽으로는 자동 형 변환이 일어나지만, 반대의 경우 명시적으로 지정을 해줘야 합니다.\r\n\r\n```java\r\nFoo foo = new Foo();\r\nObject obj = foo;\r\n```\r\n\r\n- `Foo` 클래스는 `Object` 클래스를 상속받아 생성되므로, `Object`객체 + @ 가 됩니다.\r\n- 즉, `Object` 내용을 포함한 더 많은 것을 가지고 있기 때문에 자동으로 형 변환이 일어납니다.\r\n\r\n```java\r\nFoo foo = new Foo();\r\nObject obj = foo;\r\n\r\nFoo fo = (Foo) obj; // error\r\n```\r\n\r\n- 반대로 `Object` 객체를 `Foo` 타입으로 할려면 변환 할 타입을 명시적으로 지정해 줘야 합니다.\r\n- 형 변환을 하더라도 객체의 메모리 주소는 여전히 같습니다.\r\n\r\n> 기본 타입은 강제 형 변환을 하면 데이터의 변화가 있을 수 있지만, 참조 타입은 사용할 수 있는 범위가 달라지는 것이지, 해당 주소의 데이터가 손실되지는 않습니다.\r\n\r\n## 그런데 이게 다형성이랑 무슨 상관?\r\n\r\n```java\r\ninterface 동물 {\r\n  public void 움직이다();\r\n}\r\n\r\nclass 사람 implements 동물 {\r\n\r\n  @Override\r\n  public void 움직이다() {\r\n    System.out.println(\"두 발로 걷는다.\");\r\n  }\r\n\r\n  public void 생각하기() {\r\n    System.out.println(\"생각 중\");\r\n  }\r\n\r\n}\r\n\r\nclass 강아지 implements 동물 {\r\n\r\n  @Override\r\n  public void 움직이다() {\r\n    System.out.println(\"네 발로 걷는다.\");\r\n  }\r\n\r\n  public void 물기() {\r\n    System.out.println(\"물어버렸다\");\r\n  }\r\n}\r\n```\r\n\r\n```java\r\n사람 person = new 사람();\r\n강아지 dog = new 강아지();\r\n\r\nperson.움직이다();\r\ndog.움직이다();\r\n\r\n동물 ani1 = new 사람();\r\n동물 ani2 = new 강아지();\r\n\r\nani1.움직이다();\r\nani2.움직이다();\r\n```\r\n\r\n위의 두 클래스는 `interface 동물`을 `implements`을 받아서 `움직이다()`라는 메소드를 각각 **Overriding**했습니다.\r\n그렇기 때문에 `동물` 타입으로 형 변환을 하고 `움직이다()` 메소드를 사용하면 같은 `동물`형 임에도 다른 결과를 얻을 수 있습니다.\r\n\r\n즉, 우리는 하나의 자료형임에도 하위 클래스에서 **Overriding**한 메소드에 따라 다른 결과를 얻어낼 수 있게 됩니다.\r\n\r\n> 하나의 자료형에 다른 객체를 넣어 다양한 결과를 가져 오는 것. 그것이 클래스의 다형성입니다.","headTitle":"Casting (형 변환)","fileList":[]},"__N_SSG":true}