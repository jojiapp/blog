{"pageProps":{"mdFile":"# Abstraction (추상화)\r\n\r\n## 추상화 란?\r\n\r\n자식 클래스에서 공통점을 추출하여 부모 클래스에 선언하는 것을 말합니다.\r\n\r\n## 추상 클래스 (Abstract Class) 란?\r\n\r\n일반 클래스에서 추상화가 추가 된 클래스 입니다.\r\n\r\n### 추상 클래스의 특징\r\n\r\n- 추상 클래스는 직접 인스턴스를 생성할 수 없습니다.\r\n- 추상 클래스에 선언된 추상 메소드는 **반드시 Overriding**해야 합니다.\r\n\r\n### 추상 클래스 사용방법\r\n\r\n- 접근 제한자 뒤에 `abstract` 키워드를 붙여 만들 수 있습니다.\r\n\r\n*Foo.java*\r\n\r\n```java\r\npublic abstract class Foo {\r\n  public abstract void print();\r\n\r\n  public void println() {\r\n    System.out.println(\"Foo\");\r\n  }\r\n}\r\n```\r\n\r\n*Goo.java*\r\n\r\n```java\r\npublic class Goo extends Foo {\r\n  @Override\r\n  public void print() {\r\n    System.out.println(\"Goo\");\r\n  }\r\n}\r\n```\r\n\r\n*Ex.java*\r\n\r\n```java\r\npublic class Ex {\r\n  public static void main(String[] args) {\r\n    Foo foo = new Foo(); // error\r\n    Foo goo = new Goo(); // 가능\r\n\r\n    goo.print(); // Goo\r\n    goo.println(); // Foo\r\n  }\r\n}\r\n```\r\n\r\n기본적으로 일반 클래스 상속과 똑같지만, `abstract` 키워드가 들어간 메소드는 반드시 **Overriding** 해야 하며, 직접 인스턴스 생성은 불가능 하여, 자식 인스턴스를 주입 받아야 합니다. 그렇다고\r\n추상 클래스에 무조건 추상 메소드가 들어갈 필요는 없습니다.\r\n\r\n추상 메소드를 **Overriding**하기 싫다면, 해당 클래스로 추상 클래스가 되면 됩니다.\r\n\r\n> 단, 그렇다고 하더라도 `abstract` 키워드가 붙은 클래스(추상 클래스)는 인스턴스를 직접 생성할 수는 없고, 반드시 자식 클래스의 인스턴스를 주입 받아야 합니다.\r\n\r\n## 인터페이스 (Interface) 란?\r\n\r\n추상 클래스가 일반 클래스 + 추상화라면, 인터페이스는 Only 추상화입니다.\r\n\r\n### 인터페이스 특징\r\n\r\n- 상수와, 추상 메소드만 가질 수 있습니다.\r\n- 상속과는 다르게 다중 구현이 가능합니다.\r\n- 인터페이스는 직접 인스턴스를 생성할 수 없습니다.\r\n- 인터페이스에 선언된 추상 메소드는 **반드시 Overriding**해야 합니다.\r\n\r\n### 인터페이스 사용 방법\r\n\r\n*Foo.interface*\r\n\r\n```java\r\npublic interface Foo {\r\n  String name = \"foo\";\r\n\r\n  void print();\r\n}\r\n```\r\n\r\n*Goo.interface*\r\n\r\n```java\r\npublic interface Goo {\r\n  int age = 24;\r\n\r\n  void print(String name);\r\n}\r\n```\r\n\r\n- `class` 대신 `interface`를 적습니다.\r\n- `interface`는 정적 상수와 추상 메소드만 가능합니다.\r\n    - 필드앞에 `public static final` 생략되어 있습니다.\r\n    - 메소드 앞에 `public abstract` 생략 되어 있습니다.\r\n\r\n*Hoo.class*\r\n\r\n```java\r\npublic class Hoo implements Foo, Goo {\r\n\r\n  @Override\r\n  public void print() {\r\n    System.out.println(\"Foo Interface\");\r\n  }\r\n\r\n  @Override\r\n  public void print(String name) {\r\n    System.out.println(\"Goo Interface\");\r\n  }\r\n}\r\n```\r\n\r\n- `implements` 키워드를 이용해서 여러 개의 `interface`를 상속 받을 수 있습니다.\r\n- 모두 추상 메소드이기 때문에, 전부 **Overriding** 해주어야 합니다.\r\n\r\n*Ex.java*\r\n\r\n```java\r\npublic class Ex {\r\n\r\n  public static void main(String[] args) {\r\n    Foo foo = new Hoo();\r\n    Goo goo = new Hoo();\r\n\r\n    foo.print(); // Foo Interface\r\n    goo.print(\"goo\"); // Goo interface\r\n  }\r\n}\r\n```\r\n\r\n- 두 개의 인터페이스를 상속받아 다중 구현 했기 때문에, 두 개의 인터페이스로 모두 **UpCasting**이 가능합니다.\r\n","headTitle":"Abstraction (추상화)","fileList":[]},"__N_SSG":true}